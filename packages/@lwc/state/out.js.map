{
  "version": 3,
  "sources": ["node_modules/@lwc/signals/src/index.ts", "src/index.ts"],
  "sourcesContent": [null, "import { type Signal, SignalBaseClass } from '@lwc/signals';\nimport type {\n  Computer,\n  UnwrapSignal,\n  MakeAtom,\n  MakeComputed,\n  MakeUpdate,\n  MakeContextHook,\n  ExposedUpdater,\n  DefineState,\n} from './types.ts';\n\nconst atomSetter = Symbol('atomSetter');\n\nclass AtomSignal<T> extends SignalBaseClass<T> {\n  private _value: T;\n\n  constructor(value: T) {\n    super();\n    this._value = value;\n  }\n\n  [atomSetter](value: T) {\n    this._value = value;\n    this.notify();\n  }\n\n  get value() {\n    return this._value;\n  }\n}\n\nclass ComputedSignal<T> extends SignalBaseClass<T> {\n  private computer: Computer<unknown>;\n  private dependencies: Record<string, Signal<unknown>>;\n  private _value: T;\n  private isStale = true;\n\n  constructor(inputSignalsObj: Record<string, Signal<unknown>>, computer: Computer<unknown>) {\n    super();\n    this.computer = computer;\n    this.dependencies = inputSignalsObj;\n\n    const onUpdate = () => {\n      this.isStale = true;\n      this.notify();\n    };\n\n    for (const signal of Object.values(inputSignalsObj)) {\n      signal.subscribe(onUpdate);\n    }\n  }\n\n  private computeValue() {\n    const dependencyValues: Record<string, unknown> = {};\n    for (const [signalName, signal] of Object.entries(this.dependencies)) {\n      dependencyValues[signalName] = signal.value;\n    }\n    this.isStale = false;\n    this._value = this.computer(dependencyValues) as T;\n  }\n\n  protected override notify(): void {\n    this.isStale = true;\n    super.notify();\n  }\n\n  get value() {\n    if (this.isStale) {\n      this.computeValue();\n    }\n    return this._value;\n  }\n}\n\nconst isUpdater = (signalOrUpdater: Signal<unknown> | ExposedUpdater) =>\n  typeof signalOrUpdater === 'function';\n\nconst atom: MakeAtom = <T,>(initialValue: T) => new AtomSignal<T>(initialValue);\n\nconst computed: MakeComputed = (inputSignalsObj, computer) =>\n  new ComputedSignal(inputSignalsObj, computer);\n\nconst update: MakeUpdate = <\n  SignalSubType extends Signal<unknown>,\n  AdditionalArguments extends unknown[],\n  Updater extends (signalValues: ValuesObj, ...args: AdditionalArguments) => ValuesObj,\n  SignalsObj extends Record<string, SignalSubType>,\n  ValuesObj extends {\n    [SignalName in keyof SignalsObj]?: UnwrapSignal<SignalsObj[SignalName]>;\n  },\n>(\n  signalsToUpdate: SignalsObj,\n  userProvidedUpdaterFn: Updater,\n) => {\n  return (...uniqueArgs: AdditionalArguments) => {\n    const signalValues = {} as ValuesObj;\n\n    for (const [signalName, signal] of Object.entries(signalsToUpdate)) {\n      signalValues[signalName as keyof ValuesObj] = signal.value as ValuesObj[keyof ValuesObj];\n    }\n\n    const newValues = userProvidedUpdaterFn(signalValues, ...uniqueArgs);\n\n    for (const [atomName, newValue] of Object.entries(newValues)) {\n      signalsToUpdate[atomName][atomSetter](newValue);\n    }\n  };\n};\n\nexport const defineState: DefineState = (defineStateCallback) => {\n  return (...args) => {\n    class StateManagerSignal<OuterStateShape> extends SignalBaseClass<OuterStateShape> {\n      private internalStateShape: Record<string, Signal<unknown> | ExposedUpdater>;\n      private _value: OuterStateShape;\n      private isStale = true;\n\n      constructor() {\n        super();\n\n        // @ts-ignore TODO: W-16769884\n        const fromContext: MakeContextHook = () => {};\n\n        this.internalStateShape = defineStateCallback(atom, computed, update, fromContext)(...args);\n\n        for (const signalOrUpdater of Object.values(this.internalStateShape)) {\n          if (!isUpdater(signalOrUpdater)) {\n            // Subscribe to changes to exposed state atoms and computeds, so that the entire\n            // state manager signal \"reacts\" when the atoms/computeds change.\n            (signalOrUpdater as Signal<unknown>).subscribe(this.scheduledNotify.bind(this));\n          }\n        }\n      }\n\n      private computeValue() {\n        const computedValue = Object.fromEntries(\n          Object.entries(this.internalStateShape).map(([key, signalOrUpdater]) => {\n            if (isUpdater(signalOrUpdater)) {\n              return [key, signalOrUpdater];\n            }\n            return [key, signalOrUpdater.value];\n          }),\n        );\n\n        this._value = Object.freeze(computedValue) as OuterStateShape;\n        this.isStale = false;\n      }\n\n      private scheduledNotify() {\n        this.isStale = true;\n        super.notify();\n      }\n\n      get value() {\n        if (this.isStale) {\n          this.computeValue();\n        }\n        return this._value;\n      }\n\n      // TODO: instances of this class must take the shape of `ContextProvider` and `ContextConsumer` in\n      //       the same way that it takes the shape/implements `Signal`\n    }\n\n    return new StateManagerSignal();\n  };\n};\n"],
  "mappings": "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",
  "names": []
}
